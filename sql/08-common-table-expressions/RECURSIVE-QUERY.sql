/*
    Author: David Castrillón
    Date: 2023
*/

-- RECURSIVE QUERY

/*
    - The CTEs are like temporary tables that exist only during the execution of the query.
    - A recursive query is a query that refers to a recursive CTE. The recursive queries are useful in many
        situations such as querying hierarchical data like organizational structure, bill of materials, etc.
    - In case you are storing hierarchical data (e.g. a tree) in a relational format (e.g. where rows have a foreign
        key to another row — the parent — in the same table), you can basically return all the subtree records
        (all the levels) starting from an initial filter (e.g. selection of the root node).

    RECURSIVE CTE STRUCTURE:
    - Non-recursive term: the non-recursive term is a CTE query definition that forms the base result set of the CTE
        structure.
    - Recursive term: the recursive term is one or more CTE query definitions joined with the non-recursive term using
        the UNION or UNION ALL operator. The recursive term references the CTE name itself.
    - Termination check: the recursion stops when no rows are returned from the previous iteration.

    ORDER OF EXECUTION:
    - Execute the non-recursive term to create the base result set (R0).
    - Execute recursive term with Ri as an input to return the result set Ri+1 as the output.
    - Repeat step 2 until an empty set is returned. (termination check)
    - Return the final result set that is a UNION or UNION ALL of the result set R0, R1, … Rn

*/

-- sample query
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    full_name VARCHAR NOT NULL,
    manager_id INT
);
INSERT INTO employees (
    employee_id,
    full_name,
    manager_id
)
VALUES
    (1, 'Michael North', NULL),
    (2, 'Megan Berry', 1),
    (3, 'Sarah Berry', 1),
    (4, 'Zoe Black', 1),
    (5, 'Tim James', 1),
    (6, 'Bella Tucker', 2),
    (7, 'Ryan Metcalfe', 2),
    (8, 'Max Mills', 2),
    (9, 'Benjamin Glover', 2),
    (10, 'Carolyn Henderson', 3),
    (11, 'Nicola Kelly', 3),
    (12, 'Alexandra Climo', 3),
    (13, 'Dominic King', 3),
    (14, 'Leonard Gray', 4),
    (15, 'Eric Rampling', 4),
    (16, 'Piers Paige', 7),
    (17, 'Ryan Henderson', 7),
    (18, 'Frank Tucker', 8),
    (19, 'Nathan Ferguson', 8),
    (20, 'Kevin Rampling', 8);
SELECT * FROM employees;

-- RECURSIVE QUERY
-- subordinates of the manager with id 2

WITH RECURSIVE subordinates AS (
    -- non recursive term
    SELECT
        employee_id,
        manager_id,
        full_name
    FROM
        employees
    WHERE
        employee_id = 2

    UNION

    -- recursive term
    SELECT
        e.employee_id,
        e.manager_id,
        e.full_name
    FROM
        employees e
    INNER JOIN subordinates s
        -- join previous resul set, and match from e
        -- those that have the employee_id from the
        -- previous set as manager_id
        ON s.employee_id = e.manager_id
)
SELECT
    *
FROM
    subordinates;

DROP TABLE employees;
/*
    STEP BY STEP:

    1)
    - The recursive CTE, subordinates, defines one non-recursive term and one recursive term.
    - The non-recursive term returns the base result set R0 that is the employee with the id 2.

     employee_id | manager_id |  full_name
    -------------+------------+-------------
               2 |          1 | Megan Berry

    The recursive term returns the direct subordinate(s) of the employee id 2. This is the result of joining between
    the employees table and the subordinates CTE. The first iteration of the recursive term returns the following result set:

     employee_id | manager_id |    full_name
    -------------+------------+-----------------
               6 |          2 | Bella Tucker
               7 |          2 | Ryan Metcalfe
               8 |          2 | Max Mills
               9 |          2 | Benjamin Glover

    2)
    - The second iteration of the recursive member uses the result set above step as the input value, and returns this
        result set:

     employee_id | manager_id |    full_name
    -------------+------------+-----------------
              16 |          7 | Piers Paige
              17 |          7 | Ryan Henderson
              18 |          8 | Frank Tucker
              19 |          8 | Nathan Ferguson
              20 |          8 | Kevin Rampling

    3)
    - The third iteration returns an empty result set because there is no employee reporting to the employee
        with the id 16, 17, 18, 19, and 20.

    4)
    - PostgreSQL returns the final result set that is the union of all result sets in the first and second iterations
        generated by the non-recursive and recursive terms.

     employee_id | manager_id |    full_name
    -------------+------------+-----------------
               2 |          1 | Megan Berry
               6 |          2 | Bella Tucker
               7 |          2 | Ryan Metcalfe
               8 |          2 | Max Mills
               9 |          2 | Benjamin Glover
              16 |          7 | Piers Paige
              17 |          7 | Ryan Henderson
              18 |          8 | Frank Tucker
              19 |          8 | Nathan Ferguson
              20 |          8 | Kevin Rampling
*/

-- samples table second example
CREATE TABLE people (
    id integer,
    name varchar,
    parent_id integer
);
INSERT INTO people
VALUES
    (1,'grandfather', null),
    (2,'father', 1),
    (3,'child1', 2),
    (4,'child2', 2),
    (5,'other person non connected to the hierarchy', null);

WITH RECURSIVE family AS (
    -- non-recursive term
    SELECT
        id,
        name,
        parent_id
    FROM
        people
    WHERE
        name = 'grandfather'

    UNION

    -- recursive term
    SELECT
        p.id,
        p.name,
        p.parent_id
    FROM
        people p
    JOIN family as f
        -- join on people that have
        -- as parent the people of
        -- returned set
        ON f.id = p.parent_id
)
SELECT
    *
FROM family;

DROP TABLE people;